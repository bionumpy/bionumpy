<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bionumpy &mdash; bionumpy  documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Installation" href="installation.html" />
    <link rel="prev" title="Welcome to bionumpy’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> bionumpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">bionumpy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#features">Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#io">IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequences">Sequences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#encodings">Encodings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summarization">Summarization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kmers">kmers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bionumpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>bionumpy</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/readme.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="bionumpy">
<h1>bionumpy<a class="headerlink" href="#bionumpy" title="Permalink to this headline">¶</a></h1>
<a class="reference external image-reference" href="https://pypi.python.org/pypi/bionumpy"><img alt="https://img.shields.io/pypi/v/bionumpy.svg" src="https://img.shields.io/pypi/v/bionumpy.svg" /></a>
<a class="reference external image-reference" href="https://travis-ci.com/knutdrand/bionumpy"><img alt="https://img.shields.io/travis/knutdrand/bionumpy.svg" src="https://img.shields.io/travis/knutdrand/bionumpy.svg" /></a>
<a class="reference external image-reference" href="https://bionumpy.readthedocs.io/en/latest/?version=latest"><img alt="Documentation Status" src="https://readthedocs.org/projects/bionumpy/badge/?version=latest" /></a>
<p>Library for working with biological sequence data as numpy arrays.</p>
<ul class="simple">
<li><p>Free software: MIT license</p></li>
<li><p>Documentation: <a class="reference external" href="https://uio-bmi.github.io/bionumpy/">https://uio-bmi.github.io/bionumpy/</a>.</p></li>
</ul>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>bioNumpy is a library for handling large biological sequence date sets in Python. The main features of bioNumpy are input and output from common file formats (fastq, fasta, bed, bam, sam…) (IO); Encoding of common data types into numerical arrays (Encoding) and summarizing/counting features in a data sets (kmers, minimizers, gc content, string matching,,,).</p>
<div class="section" id="io">
<h3>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h3>
<p>The main function for file input and output is the <cite>open</cite> function, which by default deduces the file type based on the suffix, and creates a buffered reader of a sensible type. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">bionumpy</span> <span class="k">as</span> <span class="nn">bnp</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fastq_entries_stream</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;example_data/reads.fq&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">fastq_entries</span> <span class="ow">in</span> <span class="n">fastq_entries_stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">fastq_entries</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">SequenceEntryWithQuality(name=Sequences(headerishere, anotherheader), sequence=Sequences(CTTGTTGA, CGG), quality=Sequences(!!!!!!!!, ~~~))</span>
</pre></div>
</div>
<p>A couple of things to note: Firstly the <cite>bnp.open</cite> function understands that the <cite>.fq</cite> suffix means it’s a fastq file and reads it as such. It also knowns that usually a <cite>fastq</cite> file is usually too big to keep in memory so instead of reading in the whole file, it reads in chunks of data and delivers it as a stream (In this particular case, the file is so small that we only get one chunk). Third, it delivers the data for each chunk as a <cite>npdataclass</cite> where there is one array-like object for each field. This means that if we only care about the acutal DNA-sequences, we can operate on that on it’s own.</p>
<p>Another example would be to read in a vcf-file as such:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">variants_stream</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;example_data/variants.vcf&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">variants</span> <span class="ow">in</span> <span class="n">variants_stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">variants</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Variant(chromosome=[&#39;chr1&#39; &#39;chr1&#39; &#39;chr1&#39;], position=array([883624, 887559, 887800]), ref_seq=Sequences(A, A, A), alt_seq=Sequences(G, C, G))</span>
<span class="go">Variant(chromosome=[&#39;chr9&#39; &#39;chr9&#39; &#39;chr9&#39;], position=array([883624, 887559, 887800]), ref_seq=Sequences(A, A, A), alt_seq=Sequences(G, C, G))</span>
</pre></div>
</div>
<p>Again, <cite>bnp.open</cite> recognizes that this is a vcf file, and again it chooses an appropriate format to output it in. For vcf file this is a stream variant chunks, where each chunk is the variants for one chromosome. This format together with the <cite>ChromosomeMap</cite> decorator makes it easy to work with genomic data.</p>
</div>
<div class="section" id="sequences">
<h3>Sequences<a class="headerlink" href="#sequences" title="Permalink to this headline">¶</a></h3>
<p><cite>bnp.Sequences</cite> objects are numpy arrays structured in a way that allows them to hold many sequences of unequal lenght. Under the hood they are <cite>npstructures.RaggedArray</cite> objects that hold byte-arrays, with an encoding that specifies which characters each byte represents. Most of the time, it is not necessary to think about these inner workings, but one can think of them as lists of strings (with the possibility of performing numpy functions on them). The most common way to get <cite>Sequences</cite> objects is to read a file, but they can also be created from lists of strings using the <cite>bnp.as_sequence_array</cite> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bnp</span><span class="o">.</span><span class="n">as_sequence_array</span><span class="p">([</span><span class="s2">&quot;acgttgta&quot;</span><span class="p">,</span> <span class="s2">&quot;gcttca&quot;</span><span class="p">,</span> <span class="s2">&quot;gttattc&quot;</span><span class="p">])</span>
<span class="go">Sequences(acgttgta, gcttca, gttattc)</span>
</pre></div>
</div>
</div>
<div class="section" id="encodings">
<h3>Encodings<a class="headerlink" href="#encodings" title="Permalink to this headline">¶</a></h3>
<p>The main point of bioNumpy is to leverage the computational power of numpy for biological data. A key element to this is to represent different types of biological data as numbers (in numpy arrays). The basic mechanism for doing this is by Encoding classes that can encode data types into numbers, and decode them back in to the data type. A driving idea in bionumpy is to make this happen automatically under the hood, so that a user can choose to ignore the inner workings and (in most cases) relate to sequence data sets in the same way as one would with standard numerical numpy data structures.</p>
</div>
<div class="section" id="summarization">
<h3>Summarization<a class="headerlink" href="#summarization" title="Permalink to this headline">¶</a></h3>
<p>A key application is to extract features from sequence data sets. A large set of interesting features can be computed as functions from sequences to scalar values. Examples are kmer-hashing (kmer-&gt;hash-value), minimizers(window-&gt;hash-value), string/motif-matching (sequence-&gt;bool), Position Weight Matrix scores (sequence-&gt;float). bioNumpy provides functionality to apply such functions to rolling windows across large sequence sets, through the <cite>RollableFunction</cite> class. By specifying a broadcastable function in the <cite>__call__</cite> method, the <cite>rolling_window</cite> method will apply the function to all windows in a sequence set. Take the <cite>PositionWeightMatrix</cite> class for instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PositionWeightMatrix</span><span class="p">(</span><span class="n">RollableFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">ACTGEncoding</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">ACTGEncoding</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="n">as_sequence_array</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span><span class="p">[</span><span class="n">sequence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s <cite>__call__</cite> method specifies how to calculate the score of a sequence. Calling it’s rolling_window function will calculate the scores for all windows in a data set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sequences</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">as_sequence_array</span><span class="p">([</span><span class="s2">&quot;acgttgta&quot;</span><span class="p">,</span> <span class="s2">&quot;gcttca&quot;</span><span class="p">,</span> <span class="s2">&quot;gttattc&quot;</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">bnp</span><span class="o">.</span><span class="n">encodings</span><span class="o">.</span><span class="n">ACTGEncoding</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">position_weight_matrix</span><span class="o">.</span><span class="n">PositionWeightMatrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="p">(</span><span class="s2">&quot;ac&quot;</span><span class="p">)</span>
<span class="go">-3.506557897319982</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="p">([</span><span class="s2">&quot;ac&quot;</span><span class="p">,</span> <span class="s2">&quot;cg&quot;</span><span class="p">])</span>
<span class="go">array([-3.5065579 , -2.52572864])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
<span class="go">RaggedArray([[-3.506557897319982, -2.525728644308255, -3.506557897319982, -3.2188758248682006, -1.83258146374831, -3.506557897319982, -2.525728644308255], [-2.4079456086518722, -3.9120230054281455, -3.2188758248682006, -2.120263536200091, -3.2188758248682006], [-3.506557897319982, -3.2188758248682006, -2.525728644308255, -4.605170185988091, -3.2188758248682006, -2.120263536200091]])</span>
</pre></div>
</div>
<p>Further processing can be done with numpy functions, for instance finding the max score for each sequence in the set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([-1.83258146, -2.12026354, -2.12026354])</span>
</pre></div>
</div>
</div>
<div class="section" id="kmers">
<h3>kmers<a class="headerlink" href="#kmers" title="Permalink to this headline">¶</a></h3>
<p>Another example of this concept is the kmer hashing class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">KmerEncoding</span><span class="p">(</span><span class="n">RollableFunction</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">alphabet_size</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet_size</span> <span class="o">=</span> <span class="n">alphabet_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet_size</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sequence</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convolution</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the <cite>__call__</cite> function specifies how to hash a kmer into a single number. Calling its <cite>rolling_window</cite> method will hash all the kmers in a sequence set.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bnp</span><span class="o">.</span><span class="n">KmerEncoding</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
<span class="go">RaggedArray([[52, 45, 43, 58, 46, 11], [39, 41, 26, 6], [43, 10, 34, 40, 26]])</span>
</pre></div>
</div>
<p>To count all the 3-mers in the ‘reads.fq’ sequences we can do as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fastq_entries_stream</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;example_data/reads.fq&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmer_encoding</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">KmerEncoding</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">fastq_entries</span> <span class="ow">in</span> <span class="n">fastq_entries_stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">kmer_hashes</span> <span class="o">=</span> <span class="n">kmer_encoding</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">fastq_entries</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">counts</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">kmer_hashes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">4</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span>
<span class="go">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,</span>
<span class="go">       0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h2>
<p>This package was created with <a class="reference external" href="https://github.com/audreyr/cookiecutter">Cookiecutter</a> and the <a class="reference external" href="https://github.com/audreyr/cookiecutter-pypackage">audreyr/cookiecutter-pypackage</a> project template.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to bionumpy’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="installation.html" class="btn btn-neutral float-right" title="Installation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Knut Rand.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>